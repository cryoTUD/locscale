{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LocScale 2.0 <sup>Confidence-weighted cryoEM map optimisation</sup>","text":"<code>LocScale 2.0</code> is an automated program for physics-informed local sharpening and/or density modification of cryo-EM maps with the aim to improve their interpretability. It utilises general properties inherent to electron scattering from biological macromolecules to restrain the sharpening filter. These can either inferred directly from the experimental density map, or be provided from an existing atomic model.   <p>What's new in LocScale 2.0</p> <ul> <li>Feature-enhanced maps: Confidence-weighted map optimisation by variational inference.</li> <li>Hybrid sharpening: Reference-based local sharpening with partial (incomplete) models.  </li> <li>Model-free sharpening: Reference-based local sharpening without atomic models.</li> <li>LocScale-SURFER: ChimeraX plugin to toggle contextual structure in <code>LocScale</code> maps</li> <li>Complete automation of the map optimisation process</li> <li>Full support for point group symmetry (helical symmetry to follow).</li> </ul>"},{"location":"#different-flavours-for-different-purposes","title":"Different flavours for different purposes","text":"<p><code>LocScale 2.0</code> comes with different modes and flavours to perform map optimisation, each with its own advantages. Please browse through the description of the different modes for usage instructions and/or scroll down to a brief guide to choose the best method for your problem. </p> <ul> <li> <p> LocScale-FEM Feature-Enhanced Maps with confidence weighting. Recommended for most cases. </p> <p></p> <p> Locscale-FEM</p> </li> <li> <p> Hybrid LocScale     Physics-based map optimisation optimally retaining contextual structure. </p> <p></p> <p> Hybrid LocScale</p> </li> <li> <p> Model-free LocScale     Automated local sharpening without model information. Fast and easy.</p> <p></p> <p> Model-free Locscale</p> </li> <li> <p> Model-based LocScale     Legacy LocScale with model information. Still useful in many cases.</p> <p></p> <p> Model-based LocScale</p> </li> </ul>"},{"location":"#how-does-locscale-20-work","title":"How does LocScale 2.0 work?","text":"<code>LocScale 2.0</code> integrates physics-informed and deep learning-based map optimisation. Physical priors for map sharpening are based on established knowledge about expected properties of electron scattering by biological macromolecules [1-3]. Alternatively, a deep convolutional neural network, <code>EMmerNet</code>, trained on pairs of unmodified maps and maps optimised with the physics-informed scaling procedure can be used to predict local scale estimates. This information is then fed into a windowed scaling procedure to produce locally sharpened maps. Both of these workflows are map sharpening procedures that operate in Fourier space, where structure factor amplitudes are corrected but map phases are locally unchanged. In a third workflow <code>LocScale-FEM</code>, a Bayesian-approximate implementation of <code>EMmerNet</code> is used to predict an optimised map (which we call feature-enhanced map) along with its uncertainties. This procedure operates in real space and affects both amplitudes and phases akin to density modification. <code>LocScale 2.0</code> computes a voxel-wise confidence score that quantifies the uncertainty of this prediction, which can be mapped onto the map to guide interpretation.   <p>What are we looking at here?</p> <p>Example of map optimisation with <code>LocScale 2.0</code> using the <code>feature_enhance</code> option. <code>LocScale 2.0</code> attempts to simultaneously enhance high-resolution structural detail and improve contrast of low(er) resolution map regions associated with flexible subunits, partial occupancy and contextual structure such as detergent micelles.</p> <p></p>"},{"location":"#flavour_guide","title":"Which map optimisation procedure should I use?","text":"<p><code>LocScale 2.0</code> supports several different workflows for automated, physics-informed map optimisation. Three of them fall into the category of local sharpening methods (i.e. they function as Fourier filters), and one \u2013\u2013feature-enhanced maps\u2013\u2013 is a map optimisation methods akin to density modification. The different methods serve different needs and we will try to guide choosing the right approach for different scenarios below.</p> <p> </p> <p>In general we recommend using <code>locscale_feature_enhance</code> for map optimisation in <code>LocScale 2.0</code> whenever applicable. We have found this procedure to work robustly in a majority of cases and to provide the best compromise in preserving high-resolution detail and enhancing contrast of flexible or lower occupancy regions and contextual structures such as micelles.  </p> <p><code>Hybrid LocScale</code> will be most useful in cases where preservation of contextual structure is of high importance and/or where a purely physics-driven map optimisation process is desirable, e.g if features to be optimised will likely fall outside the training data of <code>EMmerNEt</code> (e.g. sub-tomogram averages from in situ cryoET). If partial model information is available we recommend using all parts of the atomic model that can be reliably placed. <code>Model-free LocScale</code> is the quickest method for local sharpening and most useful for rapid testing of the effect of local sharpening, and for cases where physics-based amplitude scaling is desired but no partial model-information is available. <code>Model-based LocScale</code> is the legacy method for reference-based local sharpening using atomic model information. This can still be a useful <code>LocScale</code> mode many cases that takes full advantage of physical contraints. </p>"},{"location":"about/","title":"About LocScale 2.0","text":"<p><code>LocScale 2.0</code> has been developed by Alok Bharadwaj and Arjen Jakobi at the Kavli Institute of Nanoscience Delft, with contributions by Reinier de Bruijn to the development of EMmerNet.  </p>"},{"location":"about/#credits","title":"Credits","text":"<p><code>LoScale 2.0</code> is facilitated by a number of open-source projects.</p> <p>Projects used in LocScale</p> <ul> <li><code>EMmer</code>: Python library for electron microscopy map and model manipulations. [3-Clause BSD license]    </li> <li><code>FDRthresholding</code>: Tool for FDR-based density thresholding. [3-Clause BSD license]</li> <li><code>EMDA</code>: Electron Microscopy Data Analytical Toolkit. [MPL2.0 license]</li> <li><code>Servalcat</code>: Structure refinement and validation for crystallography and SPA. [MPL2.0 license]</li> <li><code>mrcfile</code>: MRC file I/O. [3-Clause BSD license]</li> </ul> <p><code>LocScale</code> also makes use of REFMAC5. Refmac is distributed as part of CCP-EM.</p> <p>We acknowledge the use of computational resources of the DelftBlue supercomputer, provided by Delft High Performance Computing Centre.  </p>"},{"location":"about/#references","title":"References","text":"<p>If you found <code>LocScale-2.0</code> useful for your research, please consider citing it:</p> <ul> <li>A.J. Jakobi, M. Wilmanns and C. Sachse, Model-based local density sharpening of cryo-EM maps, eLife 6: e27131 (2017).</li> <li>A. Bharadwaj and A.J. Jakobi, Electron scattering properties and their use in cryo-EM map sharpening, Faraday Discussions 240, 168-183 (2022)</li> </ul> <p>A preprint describing <code>LocScale 2.0</code> is in preparation.</p>"},{"location":"about/#bugs-and-questions","title":"Bugs and questions","text":"<p>For bug reports please use the LocScale issue tracker. </p>"},{"location":"install/","title":"Installing LocScale 2.0","text":"<p>System Compatibility</p> <p>LocScale should run on any CPU system with Linux, OS X or Windows subsytem for Linux (WSL).  </p> <p>GPU: To run the <code>feature_enhance</code> option LocScale requires the availability of a GPU. It is possible to run it on CPUs but computation will be slow(er). OpenMPI: LocScale allows parallelisation on multi-CPU environment with OpenMPI. If no OpenMPI environment exists, <code>joblib</code> is used for parallelisation.</p> <p>Installation on Apple silicon</p> <p>GPU support on Apple silicon (MX chip) has now been fixed and should work seamlessly.  </p> <p>We recommend to use Conda for a local working environment. See here for more information on what Conda flavour may be the right choice for you, and here for Conda installation instructions.</p> <ul> <li> <p> Quick installation</p> <p>Install <code>LocScale 2.0</code> and get up and running in minutes.</p> <p> Set up in 5 min</p> </li> <li> <p> Step-by-step instructions</p> <p>Step-by-step installation installation instructions.</p> <p> Install guide</p> </li> </ul>"},{"location":"install/#quick","title":"Installation via environment files:","text":""},{"location":"install/#1-install-refmac5-via-ccp4ccpem","title":"1. Install REFMAC5 via CCP4/CCPEM","text":"<p>LocScale needs a working instance of REFMAC5. If you already have CCP4/CCPEM installed check if the path to run <code>refmac5</code> is present in your environment. </p> <pre><code>which refmac5\n</code></pre> <p>If no valid path is returned, please install CCP4 to ensure refmac5 is accessible to the program. </p>"},{"location":"install/#2-install-locscale-using-environment-files","title":"2. Install LocScale using environment files","text":"<p>You will see environment.yml file in the main repo. Download this file to your local computer.</p> <p>Once you download the yml file: <pre><code>conda env create -f /path/to/environment.yml\nconda activate locscale2\n</code></pre></p>"},{"location":"install/#detailed","title":"Installation using PyPi (pip)","text":"<p>You can also follow these steps to install locscale using pip.</p>"},{"location":"install/#1-create-and-activate-a-new-conda-environment","title":"1. Create and activate a new conda environment","text":"1. Create and activate a new conda environment<pre><code>conda create -n locscale python=3.11\nconda activate locscale\n</code></pre>"},{"location":"install/#2-install-fortran-compiler","title":"2. Install fortran compiler","text":"<p>LocScale uses Fortran code to perform symmetry operations and requires a Fortran compiler to be present in your system. You can install <code>gfortran</code> from conda-forge. <pre><code>conda install -c conda-forge gfortran\n</code></pre></p>"},{"location":"install/#3-install-refmac5-via-ccp4ccpem","title":"3. Install REFMAC5 via CCP4/CCPEM","text":"<p>The model-based and hybrid map sharpening modes of LocScale need a working instance of REFMAC5. If you already have CCP4/CCPEM installed check if the path to run <code>refmac5</code> is present in your environment. For model-free sharpening and confidence-aware density modification REFMAC5 is not required. </p> <pre><code>which refmac5\n</code></pre> <p>If no valid path is returned, please install CCP4 to ensure REFMAC5 is accessible. </p>"},{"location":"install/#4-install-locscale-and-dependencies-using-pip","title":"4. Install LocScale and dependencies using pip","text":"Recommended installationDevelopment versionEditable mode <p>We recommend using pip for installation. Use pip version 21.3 or later to ensure all packages and their version requirements are met.</p> <p><pre><code>pip install locscale \n</code></pre> Install development version</p> <p>If you would like to install the latest development version of locscale, use the following command to install from the git repository.</p> <pre><code>pip install git+https://github.com/cryoTUD/locscale.git\n</code></pre> <p>To install the git repository in editable mode, clone the repository, navigate to the locscale directory, and run <code>pip install -e</code>.</p>"},{"location":"install/#5-testing","title":"5. Testing","text":"<p>To test functionality after installation, you can run LocScale unit tests using the following command:</p> <pre><code>locscale test\n</code></pre>"},{"location":"install/#locscale-20-in-ccpem-doppio","title":"LocScale 2.0 in CCPEM Doppio","text":""},{"location":"tutorials/fem/","title":"Feature-enhanced maps<sup>Confidence-weighted map optimisation</sup>","text":"<p>LocScale also supports confidence-weighted density modification based on a Bayesian-approximate implementation of <code>EMmerNet</code>, whiich strives to simultaneously optimise high-resolution detail and contrast of low(er) resolution map regions or contextual stucture. To mitigate any risk of bias from network hallucination, <code>LocScale</code> integrates this procedure with calculation of a per-pixel confidence score that effectively highlights regions requiring cautious interpretation. </p> <p>Confidence-weighted map optimisation workflow (Feature-enhanced maps)</p> <p> </p> <p>GPUs required</p> <p>Use of this option requires the availability of GPUs. It is possible to run the predictions on CPU-only setups but this will be very slow.   </p>"},{"location":"tutorials/fem/#usage","title":"Usage","text":"<pre><code>locscale feature_enhance -hm path/to/halfmap1.mrc path/to/halfmap2.mrc -v -gpus 1 -o feature_enhanced.mrc\n</code></pre> <p>Here, <code>halfmap1.mrc</code> and <code>halfmap2.mrc</code> should be the unsharpened and unfiltered half maps from yourr 3D refinement. If you wish to use the full map instead, use the following command:</p> <pre><code>locscale -em path/to/fullmap.mrc -mc path/to/model.pdb -v -gpus 1 -o feature_enhanced.mrc\n</code></pre> <p>Point group symmetry</p> <p>If your map has point group symmetry, you need to specify the symmetry to force symmetrisation of the optimised map. You can do this by specifying the required point group symmetry using the <code>-sym/--symmetry</code> flag, e.g. for D2:</p> <pre><code>locscale -hm path/to/halfmap1.mrc path/to/halfmap2.mrc -v -sym D2 -gpus 1 -o feature_enhanced.mrc\n</code></pre> <p>The output will be feature-enhanced map along with its confidence scores that can be found in the file <code>pvDDT.mrc</code>.</p> <p>Recommended use of unfiltered input maps</p> <p>Note that using unfiltered maps as input is essential. If using previously filtered maps, information beyond the spatial filter cutoff cannot be recovered.   </p> <p>Speed-up computation on multiple CPUs</p> <p>To speed up computation, you can use multiple CPUs if available. LocScale uses OpenMPI/<code>mpi4py</code> for parallelisation, which should have been automatically set up during installation. You can run it as follows:</p> <p><pre><code>mpirun -np 4 locscale -hm path/to/halfmap1.mrc path/to/halfmap2.mrc -v -gpus 1 -o feature_enhanced.mrc -mpi\n</code></pre> If use of OpenMPI is not possible on your system, you can still take advantage of multiple CPU cores by using <code>joblib</code>. In this case, simply specify the number of CPU cores using the <code>-np</code> flag as follows:</p> <pre><code>locscale -hm path/to/halfmap1.mrc path/to/halfmap2.mrc -v -gpus 1 -np 4 -o feature_enhanced.mrc\n</code></pre>"},{"location":"tutorials/fem/#pvddt","title":"Interpreting pVDDT scores","text":"<p>pVDDT scores</p> <p><code>LocScale</code> Feature-Enhanced Maps computes a voxel-wise confidence level of the optimised map, which we call the predicted Voxel-Wise Difference Test (pVDDT) score. You should always inspect LocScale FEM maps together with its confidence scores as described below. </p>"},{"location":"tutorials/fem/#visualising-confidence-weighted-maps-in-chimerax","title":"Visualising confidence-weighted maps in ChimeraX","text":"<p>The best way to visualise confidence scores is using the surface colour option in ChimeraX. <code>LocScale</code> outputs the pVDDT scores in MRC format, withc each voxel representing the pVDDT score associated with it.  </p> <p>In ChimeraX, if your model #1 refers to the feature enhanced map (<code>locscale_output.mrc</code>) and model #2 refers to the pVDDT score map (<code>pVDDT.mrc</code>), use the following command to visualise the confidence score superimposed on the map surface:  </p> <pre><code>color sample #1 map #2 palette -95,#0000ff:-80,#00ffff:0,#00ff00:80,#ffff00:95,#ff0000\n</code></pre> <p>pVDDT score interpretation</p> <p>pVDDT scores provide an intutive way for objective map interpretation by highlighting regions that may require caution because. these regions display density that significantly deviates from the density in amplitude-only modified maps. Note that these scores do not necessarily mean that these regions should not be interpreted, just that their confidence is low(er).   </p> <p></p>"},{"location":"tutorials/hybrid_locscale/","title":"Hybrid LocScale<sup>Reference-based local sharpening with a partial model</sup>","text":"<p>The hybrid <code>LocScale</code> workflow is useful in cases where partial model information is available but substantial map regions of interest or contextual densities cannot be modelled and/or are likely to fall outside the model generalisation of <code>EMmerNet</code>, or in cases where optimal local sharpening using a physics-based amplitude scaling procedure is desired. </p> <p>Hybrid LocScale workflow</p> <p> </p>"},{"location":"tutorials/hybrid_locscale/#usage","title":"Usage","text":"<pre><code>locscale -hm path/to/halfmap1.mrc path/to/halfmap2.mrc -mc path/to/model.pdb -v -o model_based_locscale.mrc --complete_model\n</code></pre> <p>Here, <code>halfmap1.mrc</code> and <code>halfmap2.mrc</code> should be the unsharpened and unfiltered half maps from yourr 3D refinement. If you wish to use the full map instead, use the following command:</p> <pre><code>locscale -em path/to/fullmap.mrc -mc path/to/model.pdb -v -o model_based_locscale.mrc --complete_model\n</code></pre> <p>Note that in this case no half map validation can be performed for coordinate and ADP refinement of the hybrid model.</p> <p>Recommended use of unfiltered input maps</p> <p>Note that using unfiltered maps as input is essential. Information beyond the spatial filter cutoff cannot be recovered.</p> <p>Point group symmetry</p> <p>If your map has point group symmetry, you need to specify the symmetry to force the pseudomodel generator for produce a symmetrised reference map for scaling. You can do this by specifying the required point group symmetry using the <code>-sym/--symmetry</code> flag, e.g. for D2:</p> <pre><code>locscale -hm path/to/halfmap1.mrc path/to/halfmap2.mrc -mc path/to/model.pdb -v -sym D2 -o model_based_locscale.mrc --complete_model \n</code></pre> <p>The output will be a locally sharpened map scaled according to the refined atomic B-factor distribution of the hybrid atomic/pseudoatom model.</p> <p>Speed-up computation on multiple CPUs</p> <p>To speed up computation, you can use multiple CPUs if available. LocScale uses OpenMPI/[<code>mpi4py</code> (https://mpi4py.readthedocs.io/en/stable/) for parallelisation, which should have been automatically set up during installation. You can run it as follows:</p> <pre><code>mpirun -np 4 locscale -hm path/to/halfmap1.mrc path/to/halfmap2.mrc -mc path/to/model.pdb -v -o model_based_locscale.mrc  --   complete_model -mpi\n</code></pre>"},{"location":"tutorials/locscale_ccpem_doppio/","title":"Running LocScale via CCPEM Doppio","text":"<p><code>LocScale 2</code> can be run via the CCPEM Doppio interface. The CCPEM Doppio interface supports all four <code>LocScale 2</code> modes including the most relevant advanced options for each mode.</p>"},{"location":"tutorials/locscale_ccpem_doppio/#step-by-step-tutorial","title":"Step-by-step tutorial","text":"<p>In this example we will use the Rattus norvegicus TRPV1 channel EMDB 5778 from the EMDB map and model challenge. You can download the tutorial files here.</p> <ul> <li> <p> Open Doppio GUI </p> <p> After starting up the CCPEM Doppio interface, start a new project.</p> </li> <li> <p> Locate locScale job node </p> <p> <code>LocScale</code> is located under the Map postprocessing tab in the program menu.</p> </li> <li> <p> LocScale GUI </p> <p> The LocScale GUI provides dynamic access to set all relevant parameters depending on the <code>LocScale</code> mode used.</p> </li> <li> <p> Advanced options ON </p> <p> You can toggle ON/OFF the Advanced Options menu. In most cases the default options will be just fine.</p> <p> Advanced Options</p> </li> <li> <p> Advanced options OFF </p> <p> We recommend to only change default parameters if really necessary. Here we will keep them turned off.</p> </li> <li> <p> Select LocScale mode </p> <p> In this case, choose Feature_enhance.</p> </li> <li> <p> Upload all files     Upload the relevant files. Fields will show which files are required depending on the method.</p> <p></p> </li> <li> <p> Set number of CPUs </p> <p> For most maps, it is recommended to use multiprocessing. Increase the number of MPI processes to speed up the computation.</p> </li> <li> <p> Run LocScale </p> <p> Click the Run button to start the job.</p> </li> <li> <p> Inspect Results </p> <p> Output from LocScale and any warnings/errors that it encounters will appear under Logs.</p> </li> <li> <p> XXX </p> <p> View the slices of the input half-maps and the LocScale output maps.</p> </li> <li> <p> YYY </p> <p> Visualise the 3D structure of the output using ChimeraX or Coot. Change the isosurface threshold for better viewing. The typical range for maps produced by LocScale for best visualisation is between 0.05 and 0.15.</p> </li> </ul>"},{"location":"tutorials/locscale_ccpem_doppio/#advanced","title":"Advanced options in CCPEM Doppio","text":"<p>:  LocScale-FEM  : Hybrid LocScale : Model-free LocScale : Model-based LocScale  </p> Option Notes Affected Method <code>LocScale window size</code> Choose an even number. Preferable range is between 16 and 30 , , ,   <code>Resolution</code> Halfmap resolution at FSC=0.143 <code>Input mask</code> Upload a mask or choose from dropdown. If uploaded, mask should be binarised. , , ,   <code>FDR window size</code> Window size to calculate noise statistics. Preferable range &gt; 15. <code>Use low context model</code> Uses <code>EMmerNet</code> model trained with low context data. Choose this is for high resolution data with few low order/resolution regions. <code>Monte-Carlo cycles</code> Number of samples used to predict variance using MC dropout. Useful range &gt; 8. <code>Batch size</code> Number of batches to hold in GPU.  For a single GPU of size 12GB, a batch size of 8 is optimum. If using multiple GPUs, the total batch size is distributed across all GPUs. For instance, with 3 GPUs of size 12GB, the input should be 24 (3x8) <code>Stride</code> Distance between successive cubes to sample the reconstruction box.  Higher strides accelerate computation, but might contain more striding artefacts. Max value 31. <code>Pseudomodel cycles</code> Number of gradient descent iteration steps to create a pseudo-model over the unmodelled parts of the input. Preferable range &gt; 20 <code>Skip B-factor refinement</code> Choose this option if you are confident about the B-factor distribution of the input model. <code>ADP refinement cycles</code> Number of REFMAC refinement cycles to model the B-factor distribution.  Preferable range &gt; 5."},{"location":"tutorials/locscale_ccpem_doppio/#advanced","title":"LocScale Doppio tutorials","text":"<p>In the following we will run through a few modes of <code>LocScale</code> in the Doppio interface to inspect the result of sharpening and/or density modification and discuss some aspects to consider.</p>"},{"location":"tutorials/locscale_ccpem_doppio/#model-free-locscale-ccpem-tutorial","title":"Model-free LocScale (CCPEM tutorial)","text":"<p>Model-free LocScale is the simplest and the quickest approach. It is good to get a quick first idea if local sharpening can improve your map, but we recommend other modes for final map improvement.</p> <ul> <li>From the main GUI launch the LocScale task window.</li> <li>Enter the following parameters and hit Run:</li> </ul> <pre><code>Input halfmap 1: emd5778_half_map_1.mrc\nInput halfmap 2: emd5778_half_map_2.pdb\nMethod: Model-free\nSymmetry group: C4\nUse GPU acceleration: No\nUse MPI: True\nMPI nodes: 3 (or 4)\n</code></pre> <p>The computations can be sped up by using parallel processing via MPI. Choose this option if your computer has multiple processors available. Note that if you have a symmetric map you need to specify the point group symmetry. To test why, you can also try re-running the job with C1 symmetry. Compare the map to the initial starting map (i.e. one of the half maps). Do you see any improvement?</p>"},{"location":"tutorials/locscale_ccpem_doppio/#hybrid-locscale-ccpem-tutorial","title":"Hybrid LocScale (CCPEM tutorial)","text":"<p>Hybrid-mode <code>LocScale</code> is a powerful approach if you have (partial) model information available. It typically is slow as it requires refining ADPs of the pseudo-atomic model, but it is the method of choice if your map contains large unmodellled areas and/or map modifications that may not have been seen yet by the <code>EMmerNet</code> training set. In this case we will use partial atomic model that only covers the well-defined transmembrane region of the TRPv1 channel.</p> <ul> <li>From the main GUI launch the LocScale task window.</li> <li>Enter the following parameters and hit run:</li> </ul> <pre><code>Input halfmap 1: emd5778_half_map_1.mrc\nInput halfmap 2: emd5778_half_map_2.pdb\nMethod: Hybrid\nInput model: pdb3j5p_incompl.pdf\nSymmetry group: C4\nUse GPU acceleration: No\nUse MPI: True\nMPI nodes: 3 (or 4)\n</code></pre> <p>Compare the map to the initial starting map (i.e. one of the half maps) and to the model-free map from the previous run. How do they compare? To better understand the rationale behind using the hybrid mode, try re-running the job with the same parameters but specify model-based as the selected method.</p>"},{"location":"tutorials/locscale_ccpem_doppio/#locscale-fem-ccpem-tutorial","title":"LocScale-FEM (CCPEM tutorial)","text":"<p>This is the default mode for LocScale2 and this mode will perform confidence-weighted density modification (i.e. it goes beyond just rebalancing the Fourier amplitude spectrum. </p> <p>Confidence scores</p> <p>Note that you should always inspect LocScale FEM maps together with its confidence scores as described below.</p> <p>Run LocScale in feature_enhance mode using following options:  </p> <pre><code>Input halfmap 1: emd5778_half_map_1.mrc\nInput halfmap 2: emd5778_half_map_2.pdb\nMethod: Feature enhance\nSymmetry group: C4\nUse GPU acceleration: Yes\nWhich GPUs to use: 0\n</code></pre> <p>After running you will observe the following output message in the Logs:</p>"},{"location":"tutorials/model_based_locscale/","title":"Model-based LocScale<sup>Model-based local sharpening</sup>","text":"<p>Model-based sharpening is the legacy mode of local sharpening as originally introduced for the first version of LocScale descrirbed in this paper. In <code>LocScale 2.0</code>, model-based sharpening can be run in a completely automated procedure, including robust ADP refinement of the input model. Model-based LocScale can still be a very useful sharpening tool in cases where atomic models have been fitted, but the map displays substantial resolution variation.  </p> <p></p>"},{"location":"tutorials/model_based_locscale/#usage","title":"Usage","text":"<pre><code>locscale -hm path/to/halfmap1.mrc path/to/halfmap2.mrc -mc path/to/model.pdb -v -o model_based_locscale.mrc\n</code></pre> <p>Here, emmap.mrc should be the unsharpened and unfiltered density map. If you wish to use the two half maps instead, use the following command:</p> <p><pre><code>locscale -hm path/to/halfmap1.mrc path/to/halfmap2.mrc -mc path/to/model.pdb -v -o model_based_locscale.mrc\n</code></pre> The output will be a locally sharpened map scaled according to the refined atomic B-factor distribution of the supplied atomic model.</p> <p>Recommended use of unfiltered input maps</p> <p>Note that using unfiltered maps as input is essential. If using previously filtered maps, information beyond the spatial filter cutoff cannot be recovered.</p> <p>Point group symmetry</p> <p>If your map has point group symmetry, you need to specify the symmetry to force a symmetrised reference map for scaling. You can do this by specifying the required point group symmetry using the <code>-sym/--symmetry</code> flag, e.g. for D2:</p> <pre><code>locscale -hm path/to/halfmap1.mrc path/to/halfmap2.mrc -mc path/to/model.pdb -v -sym D2 -o model_based_locscale.mrc\n</code></pre> <p>Speed-up computation on multiple CPUs</p> <p>To speed up computation, you can use multiple CPUs if available. LocScale uses OpenMPI/<code>mpi4py</code> for parallelisation, which should have been automatically set up during installation. You can run it as follows:</p> <p><pre><code>mpirun -np 4 locscale -hm path/to/halfmap1.mrc path/to/halfmap2.mrc -mc path/to/model.pdb -v -o model_based_locscale.mrc -mpi\n</code></pre> If use of OpenMPI is not possible on your system, you can still take advantage of multiple CPU cores by using <code>joblib</code>. In this case, simply specify the number of CPU cores using the <code>-np</code> flag as follows:</p> <pre><code>locscale -hm path/to/halfmap1.mrc path/to/halfmap2.mrc -mc path/to/model.pdb -np 4 -v -o model_based_locscale.mrc\n</code></pre>"},{"location":"tutorials/model_free_locscale/","title":"Model-free LocScale<sup>Reference-based local sharpening without atomic model</sup>","text":"<p>If no atomic model is available, or if you do not want to use prior model information, you can use the model-free mode of LocScale. This method will predict a reference map using the <code>EMmerNet</code> network by default and is the recommended procedure for model-free local sharpening.  </p> <p></p> <p>Model-free LocScale workflow</p> <p> </p>"},{"location":"tutorials/model_free_locscale/#usage","title":"Usage","text":"<pre><code>locscale -hm path/to/halfmap1.mrc path/to/halfmap2.mrc -v -o model_free_locscale.mrc\n</code></pre> <p>Here, <code>halfmap1.mrc</code> and <code>halfmap2.mrc</code> should be the unsharpened and unfiltered half maps from your 3D refinement. If you wish to use the full map instead, use the following command:</p> <pre><code>locscale -em path/to/fullmap.mrc -mc path/to/model.pdb -v -o model_free_locscale.mrc\n</code></pre> <p>Point group symmetry</p> <p>If your map has point group symmetry, you need to specify the symmetry to force a symmetrised reference map for scaling. You can do this by specifying the required point group symmetry using the <code>-sym/--symmetry</code> flag, e.g. for D2:</p> <pre><code>locscale -hm path/to/halfmap1.mrc path/to/halfmap2.mrc -v -sym D2 -o model_free_locscale.mrc\n</code></pre> <p>The output will be a locally sharpened map scaled according to the scale factors derived from the <code>EMmerNet</code>-predicted reference map.</p> <p>Recommended use of unfiltered input maps</p> <p>Note that using unfiltered maps as input is essential. If using previously filtered maps, information beyond the spatial filter cutoff cannot be recovered.   </p>"},{"location":"tutorials/model_free_locscale/#model-free-local-sharpening-with-pseudomodels","title":"Model-free local sharpening with pseudomodels","text":"<p>Another option for model-free sharpening is use a full pseudotatom model. This can be enabled by passing the <code>--build_using_pseudomodel</code> flag when invoking <code>LocScale</code>. This mode will estimate the molecular volume using statistical thresholding and generate a pseudo-atomic model within the thresholded boundary to approximate the distribution of atomic scatterers and estimate the local B-factor. It will then generate an average reference profile for local sharpening based on the experimental data and expected properties for electron scattering of biological macromolecules [2]. Use this if the default <code>EMmerNet</code>-based reference map generation does not work well for your data (e.g. if the map is too noisy or if the map has very low resolution).</p> <pre><code>locscale -hm path/to/halfmap1.mrc path/to/halfmap2.mrc -v -o model_free_locscale.mrc --build_using_pseudomodel\n</code></pre> <p>Usually all default parameters for pseudomodel and reference profile generation are fine and we do not recommend to change them, but you can change them if you deem fit.</p> <p>Point group symmetry</p> <p>If your map has point group symmetry, you need to specify the symmetry to force the pseudomodel generator for produce a symmetrised reference map for scaling. You can do this by specifying the required point group symmetry using the <code>-sym/--symmetry</code> flag, e.g. for D2:</p> <pre><code>locscale -hm path/to/halfmap1.mrc path/to/halfmap2.mrc -v -sym D2 -o model_free_locscale.mrc\n</code></pre> <p>The output will be a locally sharpened map scaled according to the local scale factors derived from the ADP distribution of the hybrid pseudoatom model.</p> <p>Speed-up computation on multiple CPUs</p> <p>To speed up computation, you can use multiple CPUs if available. LocScale uses OpenMPI/<code>mpi4py</code> for parallelisation, which should have been automatically set up during installation. You can run it as follows:</p> <p><pre><code>mpirun -np 4 locscale -hm path/to/halfmap1.mrc path/to/halfmap2.mrc -v -o model_free_locscale.mrc -mpi\n</code></pre> If use of OpenMPI is not possible on your system, you can still take advanta</p> <p>ge of multiple CPU cores by using <code>joblib</code>. In this case, simply specify the num ber of CPU cores using the <code>-np</code> flag as follows:</p> <pre><code>```bash\nlocscale -hm path/to/halfmap1.mrc path/to/halfmap2.mrc -np 4 -v -o model_free_locscale.mrc\n```\n</code></pre>"},{"location":"tutorials/options/","title":"Advanced options","text":""},{"location":"tutorials/options/#locscale-arguments","title":"LocScale arguments","text":"<pre><code>optional arguments:\n  -h, --help                                       | show this help message and exit\n  -em EMMAP_PATH, --emmap_path EMMAP_PATH          | Path to unsharpened EM map\n  -hm HALFMAP_PATHS, --halfmap_paths HALFMAP_PATHS | Paths to first and second halfmaps\n  -mm MODEL_MAP, --model_map MODEL_MAP             | Path to model map file\n  -mc MODEL_COORDINATES, --model_coordinates       | Path to PDB file\n  -ma MASK, --mask MASK                            | Input filename mask\n  -o OUTFILE, --outfile OUTFILE                    | Output filename\n  -v, --verbose                                    | Verbose output\n</code></pre> <p><code>--output_report                                  | Print a PDF copy of the report   --report_filename REPORT_FILENAME                | Filename for storing PDF output and statistics   -op OUTPUT_PROCESSING_FILES, --output_processing_files OUTPUT_PROCESSING_FILES                         Path to store processing files</code> <pre><code>  -wn WINDOW_SIZE, --window_size WINDOW_SIZE\n                        window size in pixels\n  -mpi, --mpi           MPI version\n  -np NUMBER_PROCESSES, --number_processes NUMBER_PROCESSES\n                        Number of processes to use\n  -ref_it, --refmac_iterations   | For atomic model refinement: number of refmac\n                        iterations\n  --ref_resolution            | Resolution target for Refmac refinement\n  --apix                      | pixel size in Angstrom\n  --add_blur                  | Globally sharpen the target map for REFMAC refinement\n  --refmac5_path              | Path to refmac5 executable\n  --model_resolution          | Resolution limit for Model Map generation\n  --symmetry                  | Impose symmetry condition for output\n  --fdr_window_size           | Window size in pixels for FDR thresholding\n  --fdr_filter                | Pre-filter for FDR thresholding\n  --pseudomodel_method        | For pseudomodel: method\n  --total_iterations          | For pseudomodel: total iterations\n  --distance                  | For pseudomodel: typical distance between atoms\n  --molecular_weight          | Input molecular weight (in kDa)\n  --build_ca_only             | For gradient pseudomodel building: use only Ca atoms\n                                with interatomic distance 3.8\n  --smooth_factor             | Smooth factor for merging profiles\n  --boost_secondary_structure | Amplify signal corresponding to secondary structures\n  --ignore_profiles           | Ignore average secondary structure profile during\n                               local scaling\n  --no_reference              | Run locscale without using any reference information\n  --ignore_profiles           | Ignore average secondary structure profile during\n                                local scaling\n  --skip_refine               | Ignore REFMAC refinement\n</code></pre></p>"}]}